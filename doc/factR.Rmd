---
title: "Using factR"
author: "Fursham Hamid"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    number_sections: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{factR}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, echo=FALSE, cache=FALSE}
## Global options
options(max.print="75")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>")
knitr::opts_knit$set(width=75)
```


```{r silentload, include=FALSE}
#Silent load all dependencies for vignette
library(factR)
library(AnnotationHub)
library(Biostrings)
library(BSgenome.Mmusculus.UCSC.mm10)
library(GenomicFeatures)
library(rtracklayer)
```

# Introduction
High throughput RNA-sequencing experiments have expanded discovery of new RNA isoforms. Current bioinformatic pipelines to process these data typically involve aligning  sequencing reads to reference genome and assembling contiguous reads into transcript architectures. This outputs full descriptions of transcript and exon coordinates in Gene Transfer Format (GTF) file. Further analyses including experiment-specific transcript expression can be performed using these custom-assembled transcriptome as input. Despite having rich details on transcript architectures, the newly assembled transcripts often lack coding (CDS) information. 

To this end, we developed a program with tools to Functionally Annotate Custom-assembled Transcripts in R (*factR*). At its core, *factR* constructs CDS information on custom transcriptomes using a reference-guided process. With this newly-built coding information, functional consequences can be investigated. *factR* can predict presence of protein domain families on coding transcripts and test its susceptibility to nonsense-mediated decay. *factR* also contain supporting tools to annotate alternative-spliced segments, match gene metadata and plot transcript architectures.

# Getting started

## Installing *factR*
To install *factR*, open your R environment and type:
```{r install.factR, eval = FALSE}
install.packages("devtools")
devtools::install_github("fursham-h/factR")
```

## Materials needed

### Custom-assembled transcriptome

Our workflow requires a custom-assembled transcriptome in the GTF format as an input. Users may provide their own custom GTF files, or use our sample pre-assembled GTF. It is mandatory that your transcriptome contain **gene_id** and **transcript_id** attributes. 
<!-- *In the future, add how to assemble transcriptome* -->

### Reference annotation

Several *factR* functions require reference annotation (GTF or GFF3) as guide. This can be acquired from within R environment using packages such as *AnnotationHub* or downloaded from external database such as GENCODE or Ensembl. We describe 2 ways to retrieve such reference in [this](#retrieve-annotation) section below.


### Genomic sequence

Genomic DNA sequence is required for determining open-reading frames and for *in silico* translation of query transcripts. Users may acquire reference genome from R packages such as *BSgenome* or *AnnotationHub*, or download from external database such as GENCODE or Ensembl. We describe ways to retrieve genome sequence in [this](#retrieve-genome-fasta) section below.

# Using *factR* 
In this section, we describe a recommended workflow for running *factR*. We begin by loading *factR* into our R environment:

```{r loadfactR, eval=FALSE}
library(factR)
```

## Import and inspect custom GTF
For this workflow, we use pre-assembled transcriptome from bulk RNA-seq of mouse embryonic stem cells treated with the NMD inhibitor cycloheximide (CHX) or untreated control [(reference)](https://genome.cshlp.org/content/23/10/1636.long) as an example. This GTF file was generated using [StringTie](https://ccb.jhu.edu/software/stringtie/) assembler and contain new and known transcripts expressed from *Celf1* gene.  

*factR* interacts with GTF data stored as a GenomicRanges object with genomic interval data and relevant metadata. To create such an object from the sample GTF file, we use the `importGTF` function:
```{r importGTF}
input.file <- system.file("extdata", "sample.gtf", package = "factR")
custom.gtf <- importGTF(input.file)
```

The imported GTF file is stored as a *GenomicRanges* object.
```{r checktype}
class(custom.gtf)
```

Contents of the object can be previewed using `head`:
```{r headobj}
head(custom.gtf)
```

In addition to genomic coordinates (seqnames and ranges), a typical imported GTF file will contain metadata describing the feature type (e.g. transcript or exon), its parental gene information and its assigned transcript ID.  

The following code will calculate the total number of transcripts in the input transcriptome:
```{r counttx}
length(unique(custom.gtf$transcript_id))
```

none of which contain CDS information:
```{r countcds}
length(unique(custom.gtf[custom.gtf$type=="CDS"]$transcript_id))
```

## Plot transcripts from custom transcriptome
Users may inspect architectures of specific sets of transcripts using `viewTranscripts`. To plot transcripts from *Celf1* gene, run:
```{r plottranscripts, message=FALSE, warning=FALSE}
viewTranscripts(custom.gtf, gene_name == "Celf1")
```

StringTie2, the transcript assembler used to generate this custom GTF, typically assigns arbitrary names to newly identified transcripts (e.g. "MSTRG.x.y") and uses the same prefix for their gene IDs (e.g. "MSTRG.x"). Incidentally, this is why the output above lacks any novel *Celf1* transcripts. 

## Match gene information from custom transcriptome to reference annotation
*factR* is able to correct gene metadata on custom transcriptome using a reference annotation as guide. Such reference can be obtained from databases such as UCSC, GENCODE or Ensembl. Below, we describe 2 ways to download mouse reference annotation from GENCODE.

### Retrieve annotation
1. Using AnnotationHub package
```{r load.gencode, eval = FALSE}
# query database for mouse gencode basic annotation
library(AnnotationHub)
ah <- AnnotationHub()
query(ah, c('Mus musculus', 'gencode', 'gff'))
AnnotationHub with 9 records
#> # snapshotDate(): 2020-10-27
#> # $dataprovider: Gencode
#> # $species: Mus musculus
#> # $rdataclass: GRanges
#> # additional mcols(): taxonomyid, genome,
#> #   description, coordinate_1_based, maintainer,
#> #   rdatadateadded, preparerclass, tags, rdatapath,
#> #   sourceurl, sourcetype 
#> # retrieve records with, e.g., 'object[["AH49545"]]' 
#> 
#>             title                                          
#>   AH49545 | gencode.vM6.2wayconspseudos.gff3.gz            
#>   AH49546 | gencode.vM6.annotation.gff3.gz                 
#>   AH49547 | gencode.vM6.basic.annotation.gff3.gz           
#>   AH49548 | gencode.vM6.chr_patch_hapl_scaff.annotation....
#>   AH49549 | gencode.vM6.chr_patch_hapl_scaff.basic.annot...
#>   AH49550 | gencode.vM6.long_noncoding_RNAs.gff3.gz        
#>   AH49551 | gencode.vM6.polyAs.gff3.gz                     
#>   AH49552 | gencode.vM6.primary_assembly.annotation.gff3.gz
#>   AH49553 | gencode.vM6.tRNAs.gff3.gz   

# Download full annotation
ref.gtf <- ah[['AH49546']]
```

2. From GENCODE database
```{r import.gencode, eval=FALSE}
download.file("ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.annotation.gtf.gz",
              destfile = "gencode.vM25.annotation.gtf.gz")
ref.gtf <- importGTF("gencode.vM25.annotation.gtf.gz")
```

```{r import.gencode.silent, include=FALSE}
if(!file.exists("gencode.vM25.annotation.gtf.gz")){
  download.file("ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.annotation.gtf.gz",
              destfile = "gencode.vM25.annotation.gtf.gz")
}
ref.gtf <- importGTF("gencode.vM25.annotation.gtf.gz")
```

Note: when choosing a reference, users should consider using one with the same chromosome naming style (e.g. "chr1" or "1"). If not possible, *factR* can match the styles on both objects. Type `help(matchChromosomes)` for more info.  

### Matching gene info
Genes found in the custom custom.gtf can now be compared with the reference ref.gtf object using the `matchGeneInfo` function and novel transcripts assigned to the "official" genes, whenever possible. By default, this tool matches the query (custom.gtf) to the reference (ref.gtf) by finding overlapping coordinates:
```{r matchgenemeta, message=FALSE}
# matching gene metadata
custom.gtf <- matchGeneInfo(custom.gtf, ref.gtf)

# preview object
head(custom.gtf)
```

To tune the performance of this tool, we provide additional arguments specifying the name of columns containing "primary" and potentially "secondary" gene IDs from the query (custom.gtf). Detailed description is available on the function help page by typing `help(matchGeneInfo)`.

Now, `viewTranscripts` plots all 20 new and known transcripts of *Celf1* gene:
```{r plottranscripts2}
viewTranscripts(custom.gtf, gene_name == "Celf1")
```

## Subset transcriptome for novel transcripts
As seen in the above example, custom transcriptomes typically combine both new and previously annotated transcripts. It is sometimes meaningful to select only newly-found transcripts and work with a more managaeable transcriptome. To perform this, run the following:
```{r subsettx}
custom_new.gtf <- subsetNewTranscripts(custom.gtf, ref.gtf)
viewTranscripts(custom_new.gtf, gene_name == "Celf1")
```

The above command will subset custom.gtf transcripts with distinct exonic coordinates compared to ref.gtf and store these transcripts in the custom_new.gtf object. Some custom-built transcripts may differ from their reference counterparts by having different start or/and end coordinates, with otherwise similar exon-intron structure. To shortlist only those novel transcripts that have distinct intronic coordinates, simply set the "refine.by" argument to "intron":
```{r subsettx2}
custom_new.gtf <- subsetNewTranscripts(custom.gtf, ref.gtf, refine.by = "intron")
viewTranscripts(custom_new.gtf, gene_name == "Celf1")
```

We will use custom_new.gtf object for the remaining of this workflow.

## Construct CDS information
Functional annotation of newly assembled transcripts in factR begins by deducing their protein-coding sequences (CDSs). To search for putative CDSs, factR requires a genome sequence file, which can be obtained using R packages or downloading from online databases (e.g. UCSC, GENCODE or Ensembl). Here, we show three ways to retrieve mouse genome sequence file.  

### Retrieve genome fasta
1. Using BSgenome. This package provides support for most sequenced genomes. Mouse mm10 sequence can be downloaded as such:
```{r genomeBSgenome, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("BSgenome.Mmusculus.UCSC.mm10")
```

and loaded into R environment:

```{r loadBSgenome, eval=FALSE}
library(BSgenome.Mmusculus.UCSC.mm10)
```

2. From AnnotationHub. 
```{r genomeAhub, eval=FALSE}
library(AnnotationHub) 
ah <- AnnotationHub()
query(ah, c("mm10","2bit")) 
#> AnnotationHub with 1 record
#> # snapshotDate(): 2020-10-27
#> # names(): AH14005
#> # $dataprovider: UCSC
#> # $species: Mus musculus
#> # $rdataclass: TwoBitFile
#> # $rdatadateadded: 2014-12-15
#> # $title: mm10.2bit
#> # $description: UCSC 2 bit file for mm10 
#> # $taxonomyid: 10090
#> # $genome: mm10
#> # $sourcetype: TwoBit
#> # $sourceurl: http://hgdownload.cse.ucsc.edu/goldenpath/...
#> # $sourcesize: NA
#> # $tags: c("2bit", "UCSC", "genome") 
#> # retrieve record with 'object[["AH14005"]]' 

Mmusculus <- ah[['AH14005']]
```

3. From GENCODE database
```{r downloadGencode, eval=FALSE}
download.file("ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/GRCm38.primary_assembly.genome.fa.gz",
              "GRCm38.primary_assembly.genome.fa.gz")
Mmusculus <- readDNAStringSet("GRCm38.primary_assembly.genome.fa.gz")
```

When importing FASTA file from online database, always check for proper chromosome naming. This can be done as follows:
```{r checkfasta, eval=FALSE}
seqlevels(Mmusculus)
#> [1] "chr1 1" "chr2 2" "chr3 3" "chr4 4" "chr5 5" "chr6 6"
#> [7] "chr7 7" "chr8 8" "chr9 9"
```

In the above example, names on each chromosome do not follow standard convention (e.g. "chr1" or "1"). To correct this, run the following command:
```{r correctfasta, eval=FALSE}
library(stringr)
names(Mmusculus) <- str_split(seqlevels(Mmusculus), " ") %>% map_chr(`[`, 1)
seqlevels(Mmusculus)
#> [1] "chr1" "chr2" "chr3" "chr4" "chr5" "chr6" "chr7" "chr8"
#> [9] "chr9"
```

Note: when choosing a genome, users should consider using one with the same chromosome naming style (e.g. "chr1" or "1"). If not possible, *factR* can match the styles on both objects. Type `help(matchChromosomes)` for more info. 

### Build CDS
*factR*'s buildCDS() is a multi-step function that constructs CDSs on query transcripts using reference annotation as guide. First, a database of annotated ATGs is created and used to search for a potential translation start site on query transcripts. If successfully found, buildCDS() will look for an open-reading frame and append the CDS coordinates to the query object. This function can be run for our novel transcripts as follows:
```{r buildcds, message=FALSE}
custom_new_CDS.gtf <- buildCDS(custom_new.gtf, ref.gtf, Mmusculus)
```

The open-reading frames of our novel *Celf1* transcripts are updated:
```{r viewafterCDS}
viewTranscripts(custom_new_CDS.gtf, gene_name == "Celf1")
```

CDSs are now coloured dark blue and untranslated sequences are shown in light blue (top part of Figure 1C). Also note that by setting rescale_intron to TRUE we can see exonic regions more clearly but lose their genomic coordinates. 
```{r viewafterCDSscale}
viewTranscripts(custom_new_CDS.gtf, gene_name == "Celf1", rescale_introns = TRUE)
```

## Predict transcript susceptibility to NMD
We can now examine possible functional consequences of alternative processing events affecting the newly identified transcripts. To test which transcripts may be susceptible to NMD, use the `predictNMD` function:
```{r predictNMD1, eval=FALSE}
NMDprediction.out <- predictNMD(custom_new_CDS.gtf)
```

`predictNMD` outputs a data-frame containing information on features that may trigger NMD, and a predicted NMD sensitivity for each coding transcript.  

To identify putative NMD targets for specific genes (e.g. *Celf1*), run the following:
```{r predictNMD2}
predictNMD(custom_new_CDS.gtf, gene_name == "Celf1")
```


## Predict protein domain architecture
factR can also inspect domain structure of the protein products encoded by newly identified mRNA isoforms using its `predictDomains` tool: 
```{r predDomain1, eval=FALSE}
domains.out <- predictDomains(custom_new_CDS.gtf, Mmusculus)
```

The above code returns a data-frame containing the name, expected value and position of predicted protein domain families within each transcript.  

Since predictDomains() queries PFAM database over the internet, it may require a substantial amount of time and stable internet connection to query multiple transcripts simultaneously. To quickly explore this functionality, users may prefer to begin form smaller subsets of transcripts specified. For example, to predict the domain structure for all transcripts of the *Celf1* gene, run:
```{r predDomain2}
predictDomains(custom_new_CDS.gtf, Mmusculus, gene_name == "Celf1")
```

In addition, the domain architectures for the set of query proteins can be plotted by switching the argument “plot” to TRUE:
```{r predDomain3}
predictDomains(custom_new_CDS.gtf, Mmusculus, gene_name == "Celf1", plot = TRUE)
```

## Export output objects
The *custom_new_CDS.gtf* object can be exported to a GTF file as follows:
```{r exportgtf, eval=FALSE}
export(custom_new_CDS.gtf, "Custom_new.gtf", format = “GTF”)
```

Finally, to export *NMDprediction.out* and *domains.out* data frames as tab-delimited text files, run the following:
```{r exporttable, eval=FALSE}
write.table(NMDprediction.out, "Custom_new_NMD.txt", sep = "\t", row.names = FALSE, quote = FALSE)
write.table(domains.out, "Custom_new_domains.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```

# Citing *factR*
If you find *factR* useful and utilize it in your work, please cite:
<!-- Add citation -->


# Session Information

All of the output in this vignette was produced under the following conditions:
```{r sessioninfo}
sessionInfo()
```




