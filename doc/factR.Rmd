---
title: "Using factR"
author: "Fursham Hamid"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    number_sections: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{factR}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, echo=FALSE, cache=FALSE}
## Global options
options(max.print="75")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>")
knitr::opts_knit$set(width=75)
```


```{r silentload, include=FALSE}
#Silent load all dependencies for vignette
library(factR)
library(AnnotationHub)
library(Biostrings)
library(BSgenome.Mmusculus.UCSC.mm10)
library(GenomicFeatures)
library(rtracklayer)
library(tidyverse)
```

# Introduction
Many eukaryotic genes give rise to multiple RNA isoforms, increasing the protein-coding capacity of the genome and extending the range of post-transcriptional regulation possibilities. High-throughput sequencing is often used to deduce repertoires of transcripts expressed in specific biological samples by aligning the data to genomic sequences and assembling the alignments into transcript architectures. This typically outputs Gene Transfer Format (GTF) files describing newly identified transcripts as a set of exonic coordinates, but lacking the information about their coding sequences (CDSs; also known as ORFs) and possible biological functions. 

To this end, we developed a set of tools for functional annotation of custom-assembled transcriptomes in R (*factR*). *factR* predicts CDSs for novel RNA isoforms using a reference-guided process and then determines domain organisation of the protein products and possible susceptibility of transcripts to nonsense-mediated decay (NMD; a pathway destabilizing mRNAs with premature translation termination codons). *factR* also provides supporting tools for matching new transcripts to "official" gene IDs, visualizing transcript architectures and annotating alternatively spliced segments.

# Getting started

## Installing *factR*
To install *factR*, open your R environment and type:
```{r install.factR, eval = FALSE}
install.packages("devtools")
devtools::install_github("fursham-h/factR")
```

## Materials needed

### Custom-assembled transcriptome

*factR* requires a custom transcriptome file in the GTF format as an input, and we provide three custom transcriptome files that can be used to test *factR* tools (https://github.com/fursham-h/MiMB-factR-supplement/tree/master/Custom%20transcriptome).

1. bulk_merged.gtf.gz assembled using the HISAT2-StringtTie2 pipeline from bulk RNA-seq data for mouse embryonic stem cells treated with the NMD inhibitor cycloheximide (CHX) or left untreated as a control [(reference)](https://genome.cshlp.org/content/23/10/1636.long). 
2. sc_merged.gtf.gz assembled using the HISAT2-StringtTie2 pipeline >>> from scRNA-seq data 
3. lr_merged.gtf.gz assembled using minimap2[ref] and StringtTie2 pipeline >>> from long-read RNA-seq data

Users may alternatively prepare their own GTF files making sure that these contain both **gene_id** and **transcript_id** attributes. 
<!-- *In the future, add how to build custom GTF files* -->

### Reference transcriptome

Several *factR* functions require reference transcriptome files (GTF or GFF3) as a guide. Such files can be accessed from within the R environment using e.g. the R package *AnnotationHub* or downloaded from an external database such as GENCODE or Ensembl. Both possibilities are described in the ["Updating gene info"](#updating-gene-info) section below.


### Genome

*factR* needs genomic DNA sequence to predict CDSs and amino acid sequences of the protein products. Users may obtain genome files using e.g. *BSgenome* or *AnnotationHub* or download them from an external database such as GENCODE or Ensembl. We describe this in more detail in the ["Constructing CDS information"](#constructing-CDS-information) section below.

# Using *factR* 
We begin by loading *factR* into our R environment:

```{r loadfactR, eval=FALSE}
library(factR)
```

## Importing and inspecting GTF data

*factR* handles transcriptome information in the form of *GenomicRanges* objects containing genomic interval data and relevant metadata. To create such an object from one of our GTF file, we use the `importGTF` function:
```{r importGTF}
selected.data = "sc"

download.file(paste0("https://github.com/fursham-h/MiMB-factR-supplement/raw/master/",
                     "Custom%20transcriptome/", selected.data, "_merged.gtf.gz"), 
              "input.gtf.gz")
custom.gtf <- importGTF("input.gtf.gz")
```
Note: the above imports sc_merged.gtf.gz as an example, and we assume that this file was used as the input in the following description. To try bulk_merged.gtf.gz or lr_merged.gtf.gz, simply change "sc" to "bulk" or "lr" in the selected.data variable above.

The imported GTF file is stored as a *GenomicRanges* object.
```{r checktype}
class(custom.gtf)
```

Contents of the object can be examined using `head`:
```{r headobj}
head(custom.gtf)
```

In addition to genomic coordinates (seqnames and ranges), a typical GTF file contains metadata describing the feature type (e.g. transcript or exon), transcript IDs and some information on their parental genes.  

The following code will calculate the total number of transcripts in the input transcriptome:
```{r counttx}
length(unique(custom.gtf$transcript_id))
```

Note that none of the transcripts in the custom.gtf object contain CDS information:
```{r countcds}
length(unique(custom.gtf[custom.gtf$type=="CDS"]$transcript_id))
```

## Plotting transcript structures
Users may visualize specific sets of transcripts using `viewTranscripts`. For example, the following will plot transcripts from the *Zfr* gene encoding a conserved zinc finger-containing RNA-binding protein with known neuronal functions :
```{r plottranscripts, message=FALSE, warning=FALSE}
viewTranscripts(custom.gtf, gene_name == "Zfr")
```

StringTie2, a popular transcript assembler used to generate our custom GTF, typically assigns arbitrary names to newly identified transcripts (e.g. "MSTRG.x.y") and uses the same prefix for their gene IDs (e.g. "MSTRG.x"). Incidentally, this is why the output above lacks any novel *Zfr* transcripts. 

## Updating gene info
*factR* can update gene metadata in custom transcriptome objects using a reference annotation as guide. Below, we describe two alternative ways to obtain mouse reference transcriptome data from GENCODE.

1. Using *AnnotationHub* package
```{r load.gencode, eval = FALSE}
# query database for mouse gencode basic annotation
library(AnnotationHub)
ah <- AnnotationHub()
query(ah, c('Mus musculus', 'gencode', 'gff'))
#> AnnotationHub with 9 records
#> # snapshotDate(): 2020-10-27
#> # $dataprovider: Gencode
#> # $species: Mus musculus
#> # $rdataclass: GRanges
#> # additional mcols(): taxonomyid, genome,
#> #   description, coordinate_1_based, maintainer,
#> #   rdatadateadded, preparerclass, tags, rdatapath,
#> #   sourceurl, sourcetype 
#> # retrieve records with, e.g., 'object[["AH49545"]]' 
#> 
#>             title                                          
#>   AH49545 | gencode.vM6.2wayconspseudos.gff3.gz            
#>   AH49546 | gencode.vM6.annotation.gff3.gz                 
#>   AH49547 | gencode.vM6.basic.annotation.gff3.gz           
#>   AH49548 | gencode.vM6.chr_patch_hapl_scaff.annotation....
#>   AH49549 | gencode.vM6.chr_patch_hapl_scaff.basic.annot...
#>   AH49550 | gencode.vM6.long_noncoding_RNAs.gff3.gz        
#>   AH49551 | gencode.vM6.polyAs.gff3.gz                     
#>   AH49552 | gencode.vM6.primary_assembly.annotation.gff3.gz
#>   AH49553 | gencode.vM6.tRNAs.gff3.gz   

# Download full annotation
ref.gtf <- ah[['AH49546']]
```

2. Downloading from a database (e.g. GENCODE)
```{r import.gencode, eval=FALSE}
download.file("ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.annotation.gtf.gz",
              destfile = "gencode.vM25.annotation.gtf.gz")
ref.gtf <- importGTF("gencode.vM25.annotation.gtf.gz")
```

```{r import.gencode.silent, include=FALSE}
if(!file.exists("gencode.vM25.annotation.gtf.gz")){
  download.file("ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.annotation.gtf.gz",
              destfile = "gencode.vM25.annotation.gtf.gz")
}
ref.gtf <- importGTF("gencode.vM25.annotation.gtf.gz")
```

Note: when choosing a reference, users should consider using one with the same chromosome naming style (e.g. "chr1" or "1"). If not possible, *factR* can attempt matching the styles on both objects (see `help(matchChromosomes)`).  

Once the ref.gtf object is ready, novel transcripts in custom.gtf can be matched to "official" gene IDs, whenever possible, using `matchGeneInfo`. By default, this function matches the query (custom.gtf) to the reference (ref.gtf) by finding overlapping coordinates:
```{r matchgenemeta, message=FALSE,eval=FALSE}
# matching gene metadata
custom.gtf <- matchGeneInfo(custom.gtf, ref.gtf)
```

To tune the performance of `matchGeneInfo`, we provide additional arguments specifying the name of columns containing "primary" and potentially "secondary" gene IDs from the query (custom.gtf). For further help, type `help(matchGeneInfo)`.
```{r matchgenemeta2, message=FALSE}
# matching gene metadata
custom.gtf <- matchGeneInfo(custom.gtf, ref.gtf, 
                            primary_gene_id = "gene_id", 
                            secondary_gene_id = "ref_gene_id")
```

Note that custom.gtf updated by `matchGeneInfo` now contains 17 new and known transcripts of *Zfr* gene:
```{r plottranscripts2}
viewTranscripts(custom.gtf, gene_name == "Zfr")
```

## Shortlisting novel transcripts
As seen in the above example, custom transcriptomes typically combine both new and previously annotated transcripts. To select only newly predicted transcripts, run the following:
```{r subsettx}
custom_new.gtf <- subsetNewTranscripts(custom.gtf, ref.gtf)
viewTranscripts(custom_new.gtf, gene_name == "Zfr")
```

This will subset custom.gtf transcripts with distinct exonic coordinates compared to ref.gtf and store these transcripts in the custom_new.gtf object. Some custom-built transcripts may differ from their reference counterparts by having different start or/and end coordinates, with otherwise similar exon-intron structure. To shortlist only those novel transcripts that have distinct intronic coordinates, simply set the "refine.by" argument to "intron":
```{r subsettx2}
custom_new.gtf <- subsetNewTranscripts(custom.gtf, ref.gtf, refine.by = "intron")
viewTranscripts(custom_new.gtf, gene_name == "Zfr")
```

We will use the custom_new.gtf object in the rest of the workflow.

## Constructing CDS information
Functional annotation of newly assembled transcripts in *factR* begins by deducing their protein-coding sequences (CDSs). To search for putative CDSs, *factR* requires a genome sequence file, which can be obtained using R packages or downloading from online databases (e.g. UCSC, GENCODE or Ensembl). Here are three alternative ways to retrieve mouse genome sequence file.  

1. Using *BSgenome*
This package provides support for most sequenced genomes. Mouse mm10 sequence can be downloaded as such:
```{r genomeBSgenome, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("BSgenome.Mmusculus.UCSC.mm10")
```

and loaded into R environment:

```{r loadBSgenome, eval=FALSE}
library(BSgenome.Mmusculus.UCSC.mm10)
```

2. Using *AnnotationHub*
```{r genomeAhub, eval=FALSE}
library(AnnotationHub) 
ah <- AnnotationHub()
query(ah, c("mm10","2bit")) 
#> AnnotationHub with 1 record
#> # snapshotDate(): 2020-10-27
#> # names(): AH14005
#> # $dataprovider: UCSC
#> # $species: Mus musculus
#> # $rdataclass: TwoBitFile
#> # $rdatadateadded: 2014-12-15
#> # $title: mm10.2bit
#> # $description: UCSC 2 bit file for mm10 
#> # $taxonomyid: 10090
#> # $genome: mm10
#> # $sourcetype: TwoBit
#> # $sourceurl: http://hgdownload.cse.ucsc.edu/goldenpath/...
#> # $sourcesize: NA
#> # $tags: c("2bit", "UCSC", "genome") 
#> # retrieve record with 'object[["AH14005"]]' 

Mmusculus <- ah[['AH14005']]
```

3. Downloading from a database (e.g. GENCODE)
```{r downloadGencode, eval=FALSE}
download.file("ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/GRCm38.primary_assembly.genome.fa.gz",
              "GRCm38.primary_assembly.genome.fa.gz")
Mmusculus <- readDNAStringSet("GRCm38.primary_assembly.genome.fa.gz")
```

When importing a FASTA file, always check if the chromosome names are consistent with the transcriptome object. This can be done as follows:
```{r checkfasta, eval=FALSE}
seqlevels(Mmusculus)
#> [1] "chr1 1" "chr2 2" "chr3 3" "chr4 4" "chr5 5" "chr6 6"
#> [7] "chr7 7" "chr8 8" "chr9 9"
```

In the above example, names on each chromosome do not follow standard convention (e.g. "chr1" or "1"). To correct this, run the following command:
```{r correctfasta, eval=FALSE}
library(stringr)
names(Mmusculus) <- str_split(seqlevels(Mmusculus), " ") %>% map_chr(`[`, 1)
seqlevels(Mmusculus)
#> [1] "chr1" "chr2" "chr3" "chr4" "chr5" "chr6" "chr7" "chr8"
#> [9] "chr9"
```

Note: when choosing a genome, users should consider using one with the same chromosome naming style (e.g. "chr1" or "1"). If not possible, *factR* can match the styles on both objects. Type `help(matchChromosomes)` for more info. 

Once the genome sequence object is ready, *factR* can predict CDSs using its buildCDS() function and reference transcriptome data as a guide. To this end, buildCDS() first generates a "database" of previously annotated ATGs and uses this information to search for a potential translation start sites in query transcripts. buildCDS() then deduces the CDS and appends its coordinates to the custom transcriptome object. To run this function for our novel transcripts:
```{r buildcds, message=FALSE}
custom_new_CDS.gtf <- buildCDS(custom_new.gtf, ref.gtf, Mmusculus)
```

Note that our novel *Zfr* transcripts have been updated with information about likely CDSs (dark blue) and untranslated regions (light blue) :
```{r viewafterCDS}
viewTranscripts(custom_new_CDS.gtf, gene_name == "Zfr")
```

We can display exonic regions and CDSs more clearly (at the expense of loosing their bona fide genomic coordinates) by setting rescale_intron argument to TRUE. 
```{r viewafterCDSscale}
viewTranscripts(custom_new_CDS.gtf, gene_name == "Zfr", rescale_introns = TRUE)
```

## Predicting NMD
To explore possible susceptibility of newly identified mRNA isoforms to NMD, we use the `predictNMD` function:
```{r predictNMD1, message=FALSE}
NMDprediction.out <- predictNMD(custom_new_CDS.gtf)
head(NMDprediction.out)
```

`predictNMD` outputs a data frame containing information on features that may trigger NMD, and a predicted NMD sensitivity for each coding transcript.  

To identify putative NMD targets for specific genes (e.g. *Zfr*), run the following:
```{r predictNMD2}
NMDprediction.Zfr <- predictNMD(custom_new_CDS.gtf, gene_name == "Zfr")
head(NMDprediction.Zfr)
```

## Predicting protein domains
*factR* can also inspect domain structure of the protein products encoded by newly identified mRNA isoforms using its `predictDomains` tool: 
```{r predDomain1, eval=FALSE}
domains.out <- predictDomains(custom_new_CDS.gtf, Mmusculus)
```
```{r silentpred, include=FALSE}
domains.out <- read.delim("sc_domains.txt")
```

The above code returns a data frame containing the name, expected value and position of predicted protein domain families within each transcript.  

Since predictDomains() connects to the PFAM database over the internet, it may require a substantial amount of time and stable internet connection to query multiple transcripts simultaneously. To quickly explore this functionality, users may prefer to begin with a small subsets of transcripts. For example, to predict the domain structure for all transcripts of the *Zfr* gene, run:
```{r predDomain2}
predictDomains(custom_new_CDS.gtf, Mmusculus, gene_name == "Zfr")
```

The domain architectures for the set of query proteins can be additionally plotted by switching the argument "plot" to TRUE:
```{r predDomain3}
domains.Zfr <- predictDomains(custom_new_CDS.gtf, Mmusculus, gene_name == "Zfr", plot = TRUE)
```

## Processing *factR* output
Dataframe outputs from `predictNMD` and `predictDomains` can be wrangled to output meaningful information. 

We begin by inspecting the NMDprediction.out dataframe. With the help of data manipulation tools from the tidyverse package, we can compute the number of NMD-sensitive and non NMD-sensitive transripts:
```{r NMDsumm1, message=FALSE}
library(tidyverse)
NMDprediction.out %>% 
  group_by(is_NMD) %>% 
  tally()
```

Furthermore, the mean 3'UTR lengths of transcripts in these 2 groups can be calculated as follows:
```{r NMDsumm2, message=FALSE}
NMDprediction.out %>% 
  group_by(is_NMD) %>% 
  summarise(mean_3UTR_length = mean(`3'UTR_length`))
  
```

We can also compare the proportion of new and known NMD-sensitive transcripts. We first have to run `predictNMD` on our reference annotation:
```{r NMDknown, eval=FALSE}
NMDprediction.known <- predictNMD(ref.gtf)
```
```{r NMDknownsilent, include=FALSE}
NMDprediction.known <- read.delim("NMD_known.txt")
```

Then, a new column "group" is added to the dataframes to label the type of transcript (new vs known).
```{r NMDanalysis1}
NMDprediction.known$group <- "Known"
NMDprediction.out$group <- "New"
```

Both dataframes are next combined, and grouped into 4 categories based on variables "group" and "is_NMD". The number of transcripts in each group will then be calculated:
```{r NMDanalysis2, message=FALSE}
proportion.NMD <- bind_rows(NMDprediction.known, NMDprediction.out) %>% 
  group_by(group, is_NMD) %>% 
  tally(name = "n_transcripts")
proportion.NMD

```

and visualized using a stacked bar-graph:
```{r NMDplot}
proportion.NMD %>% 
  ggplot(aes(x=group, y=n_transcripts, fill=is_NMD)) +
  geom_bar(stat="identity", position="fill")
```

<!-- Stopped here -->


## Export output objects
Annotated *custom_new_CDS.gtf* object can be exported to a GTF file as follows:
```{r exportgtf, eval=FALSE}
export(custom_new_CDS.gtf, "Custom_new.gtf", format = “GTF”)
```

Finally, to export *NMDprediction.out* and *domains.out* data frames as tab-delimited text files, run the following:
```{r exporttable, eval=FALSE}
write.table(NMDprediction.out, "Custom_new_NMD.txt", sep = "\t", row.names = FALSE, quote = FALSE)
write.table(domains.out, "Custom_new_domains.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```

# Citing *factR*
If you find *factR* useful, please cite it:
<!-- Add citation -->


# Session Information
This workflow was conducted on:
```{r sessioninfo}
sessionInfo()
```





