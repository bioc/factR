---
title: "Using factR"
author: "Fursham Hamid"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    number_sections: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{factR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE, cache=FALSE}
## Global options
options(max.print="75")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>")
knitr::opts_knit$set(width=75)
```


```{r silentload, include=FALSE}
#Silent load all dependencies for vignette
library(factR)
library(BSgenome.Mmusculus.UCSC.mm10)
library(wiggleplotr)
library(GenomicFeatures)
library(dplyr)
library(zeallot)
```

# Introduction
High throughput RNA sequencing experiments have been very useful in the discovery of many new RNA species. Current pipelines that processes these sequencing data usually involve aligning the reads to a genome and assembling contiguous reads into a transcript architectures. With the assembled transcripts, one may quantify the relative number of reads mapped to the list of genes/transcripts and determine differentially expressed gene/transcripts between conditions. However, these assembled transcripts commonly do not contain information on its coding potential and thus inferring its function can be a difficult task.

Here, we develop a program that Functionally Annotates Custom-assembled Transcripts in R (factR). At its core, factR will construct CDS coordinates for assembled transcriptomes with the guide of a reference annotation. With this newly-built coding information, users may utilise factR to query transcripts for protein-coding features as well as NMD-inducing features. 


# Getting started

## How to install
To install factR, open R and type:
```{r install.factR, eval = FALSE}
install.packages("devtools")
devtools::install_github("fursham-h/factR")
```

## What you need

### Query transcript assembly

Transcript assembly programs typically outputs a GTF/GFF3 file containing transcript and exon coordinates, as well as attributes for each entry. It is mandatory that your assembly contain *gene_id* and *transcript_id* attributes.

Query GTF file have to be imported into R and parsed into a GenomicRanges object. 
To do so, run:
```{r load,query, eval = FALSE}
# install rtracklayer if not yet installed
BiocManager::install("rtracklayer")

# import gtf file
library(rtracklayer)
query_gtf <- import('path/to/your.gtf')
```

### Reference annotation


Reference transcript annotation serves as a guide in the construction of query CDS. We strongly recommend using transcript annotation in GTF/GFF3 format for the workflow. This will facilitate matching of gene families between query and reference. (advanced user? see section....)

Reference GTF annotation can be acquired from the Annotation Hub database in R or downloaded locally from data server website via FTP. For the latter, the GTF file have to be imported into R and parsed into a GenomicRanges object. 

Here, we will describe three ways to obtain mouse GRCm38 annotation:

1. Gencode annotation from Annotation Hub database
```{r load.gencode, eval = FALSE}
# install package if not yet installed
BiocManager::install("AnnotationHub")

# query database for mouse gencode basic annotation
library(AnnotationHub)
ah <- AnnotationHub()
query(ah, c('Mus musculus', 'gencode', 'gff', 'basic'))
#AnnotationHub with 2 records
## snapshotDate(): 2019-05-02 
## $dataprovider: Gencode
## $species: Mus musculus
## $rdataclass: GRanges
## additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer,
##   rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype 
## retrieve records with, e.g., 'object[["AH49547"]]' 
#
#            title                                                    
#  AH49547 | gencode.vM6.basic.annotation.gff3.gz                     
#  AH49549 | gencode.vM6.chr_patch_hapl_scaff.basic.annotation.gff3.gz

# retrieve id 'AH49547'
ref_gtf <- ah[['AH49547']]
```

2. Ensembl annotation from Annotation Hub database
```{r load.ensembl, eval = FALSE}
# Load annotation hub and query database for ensembl annotation as in method 1 above.

# retrieve latest GRCm38 annotation from ensembl
ref_gtf <- ah[['AH60127']]
```

3. Import locally downloaded GTF annotation into R
```{r load.localref, eval = FALSE}
# install rtracklayer if not yet installed
BiocManager::install("rtracklayer")

# import reference gtf file
library(rtracklayer)
query_gtf <- import('path/to/reference.gtf')
```


### Genomic sequence

Genomic DNA sequence is required for determining open-reading frames and for *in silico* translation of  query transcripts. Here, we describe three ways in obtaining genomic sequence for mouse GRCm38 assembly:

1. BSgenome sequence object from UCSC
```{r load.BSgenome, eval = FALSE}
# install GRCm38 sequence object and rename for convenience
BiocManager::install("BSgenome.Mmusculus.UCSC.mm10")
library(BSgenome.Mmusculus.UCSC.mm10)
Mmusculus <- BSgenome.Mmusculus.UCSC.mm10
```

2. TwoBit fasta sequence from Annotation Hub
```{r load.fastaAH, eval = FALSE}
# install package if not yet installed
BiocManager::install("AnnotationHub")

# query database for mouse gencode basic annotation
library(AnnotationHub)
ah <- AnnotationHub()
query(ah, c("Mus musculus", "release-91", 'fasta', 'GRCm38'))
#AnnotationHub with 5 records
## snapshotDate(): 2019-05-02 
## $dataprovider: Ensembl
## $species: Mus musculus
## $rdataclass: TwoBitFile
## additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer,
##   rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype 
## retrieve records with, e.g., 'object[["AH60491"]]' 
#
#            title                                           
#  AH60491 | Mus_musculus.GRCm38.cdna.all.2bit               
#  AH60492 | Mus_musculus.GRCm38.dna.primary_assembly.2bit   
#  AH60493 | Mus_musculus.GRCm38.dna_rm.primary_assembly.2bit
#  AH60494 | Mus_musculus.GRCm38.dna_sm.primary_assembly.2bit
#  AH60495 | Mus_musculus.GRCm38.ncrna.2bit  

# retrieve id 'AH60492'
Mmusculus <- ah[['AH60492']]
```

3. Import local FASTA genome sequence file
```{r load.localfasta, eval = FALSE}
# install Biostrings package if not yet installed
BiocManager::install("Biostrings")

# load package and import fasta file as a DNAStringSet
library(Biostrings)
Mmusculus <- readDNAStringSet('path/to/fasta')
```

Note: when using DNA FASTA from Ensembl, do check header lines for entry names. If long names are given (eg. 1 dna:chromosome chromosome:GRCm38:1:1:195471971:1 REF), you would need to convert them to short names in order to have consistent sequence levels. This can be done by running the following:

```{r convert.fastaheader, eval = FALSE}
# install purrr and stringr packages if not yet installed
install.packages('purrr', 'stringr')

# load package and import fasta file as a DNAStringSet
library(purrr)
library(stringr)
names(Mmusculus) <- str_split(seqlevels(Mmusculus), " ") %>% map_chr(`[`, 1)
```


# Example workflow

This section will describe the workflow to analyze a sample GTF query.

To run the code examples shown in this workflow, we need to load the following packages:
```{r load.dep.workflow, eval = FALSE}
library(factR)
library(BSgenome.Mmusculus.UCSC.mm10)
library(wiggleplotr)
library(GenomicFeatures)
library(dplyr)
library(zeallot)
```

**Query:** 
factR package contains a sample assembled GTF imported as a GRanges object. The assembly was constructed from a mouse dataset and contain *transcript* and *exon* descriptions of 4 transcript isoforms from the same parent gene. Gene and transcript IDs have been given generic names to....

```{r checkquery}
# inspect query object
head(query_gtf)

# list out transcript_id and gene_id names
unique(query_gtf$transcript_id)

unique(query_gtf$gene_id)
```

We can quickly visualize the exon structure of these query transcripts using the *wiggleplotr* package
```{r viewquery}
# prepare a list of exons by transcript
query_exons <- split(query_gtf[query_gtf$type == 'exon'], ~transcript_id)

# list out transcript_id and gene_id names
plotTranscripts(query_exons)
```

**Reference:** 
For our reference annotation, we will be using a subset of GRCm38 gencode reference annotation which contain basic transcripts from the same gene family as our query gene. Acquisition of this annotation have been described in section 2.2.2.1.
```{r viewref}
# inspect reference object
head(ref_gtf)

# list out transcript_id and gene_id names
unique(ref_gtf$transcript_id)

unique(ref_gtf$gene_id)
```

**Genome:** 
Lastly, we will be using a GRCm38 genome sequence object from BSgenome
```{r loadfasta}
Mmusculus <- BSgenome.Mmusculus.UCSC.mm10
```

## Check and rectify input objects for cross-compatibility

Before running the core functions of factR, we have to ensure that the mandatory input objects are cross-compatible for the analysis. Two key features that has to be consistent among the inputs include:

1. Chromosome ID (seqlevels). 
This is required for many downstream analyses, including extraction of transcript sequence and construction of query CDS.
2. Matched gene_id between query and reference. 
This is required to pair query transcripts to a reference transcript based on common gene family in order to construct its CDS information.

factR comes with a tool to check the mandatory input files and return recommendations on functions to execute to increase consistency of your query object. To check the input files, run:
```{r checkinputs}
checkInputs(query_gtf, ref_gtf, Mmusculus)
```

As seen from the report above, our `query_gtf` object has inconsistent chromosome levels (seqlevels) and gene_ids. To rectify these inconsistencies, you may follow the functions as recommended.
```{r matchfuns}
# matching seqlevels
query_gtf <- matchSeqLevels(query_gtf, Mmusculus)

head(query_gtf)

# matching gene_id
query_gtf <- matchGeneIDs(query_gtf, ref_gtf)

head(query_gtf)
```

After `query_gtf`  have been rectified, we can re-check our inputs:
```{r recheckinputs}
checkInputs(query_gtf, ref_gtf, Mmusculus)
```

## Convert input objects into GRangesList

Our sample `query_gtf` and `ref_gtf` assemblies are currently formatted as a GRanges object, each of which may consist of multiple entry types (transcript, exon and cds). Therefore, we need to segregate each input into several GRangesList objects, and group the entries by its *transcript_id*. Here, we will describe two methods of conversion:

1. Manual splitting of exon/cds entries of your GRanges object based on transcript_id. This method will retain all attributes of your GRanges object, but requires a basic understanding on subsetting a GRanges object
```{r manualsplit, warning=FALSE}
# get GrangesList of query exons grouped by transcript_id
query_exons <- split(query_gtf[query_gtf$type == 'exon'], ~transcript_id)

# get GrangesList of ref cds grouped by transcript_id
ref_cds <- split(ref_gtf[ref_gtf$type == 'CDS'], ~transcript_id)

# get GrangesList of ref exons grouped by transcript_id
ref_exons <- split(ref_gtf[ref_gtf$type == 'exon'], ~transcript_id)
# keep only coding transcripts
ref_exons <- ref_exons[names(ref_exons) %in% names(ref_cds)] 

# inspect new query_exon object
is(query_exons, 'GRangesList')  #check that query_exons is a List of GRanges

names(query_exons)  # check for correct grouping of exons by transcript_id
```

2. Construct a TxDb object, followed by grouping using exonBy and cdsBy functions. This method is easier to execute but may not carry over the attributes from input GRanges.
```{r txdbsplit, eval=FALSE}
#make txdb for query and reference
queryDB = makeTxDbFromGRanges(query_gtf)
refDB = makeTxDbFromGRanges(ref_gtf)

# get GRangesList using exonsBy and cdsBy functions
query_exons = exonsBy(queryDB, by="tx", use.names=TRUE)
ref_cds = cdsBy(refDB, by="tx", use.names=TRUE)
ref_exons = exonsBy(refDB, by="tx", use.names=TRUE)
```

## Construct query CDS

In order to build CDS information on our query data, we need `query_exons`, `ref_cds` and `Mmusculus` objects, as well as a two-column dataframe containing list of query transcript_ids and its paired reference transcript_id. This dataframe can be easily constructed using the following code:
```{r prepareq2r, message=F}
# prepare dataframes with unique gene_id and transcript_id attributes for query and ref
query_ids = query_gtf %>% as.data.frame() %>%
  dplyr::select(gene_id, transcript_id) %>%
  distinct()
ref_ids = ref_gtf %>% as.data.frame() %>%
  dplyr::select(gene_id, ref_transcript_id = transcript_id) %>%
  distinct()

# join both dataframes and select only transcript_id colums
q2r <- left_join(query_ids, ref_ids) %>%
  dplyr::select(-gene_id)

q2r
```

From the example above, the reference gene contain 2 basic coding transcript. Therefore, each of the query transcripts has been paired to 2 reference transcripts. This means that each transcript on GeneA will undergo CDS construction twice, creating computational redundancy. Therefore ideally, the dataframe has to be simplified in such a way that each transcript is paired to one reference transcript. One way to achieve this is to select the reference transcript with the greatest coverage to the query transcript. To facilitate with this selection process, we can run the `calcCovs` function that is exported with factR.

Below, we will run the `calcCovs` function. The function will calculate the coverage values between the paired transcripts in q2r dataframe and return the pair with the highest coverage.
```{r getcoverage}
q2rcovs <- calcCovs(query_exons, ref_exons, q2r)

q2rcovs
```

We can now build the query cds information using the subsetted `q2rcovs` dataframe. We may also specify the `coverage` argument as the q2rcovs dataframe contain a column with coverage values. This may speed up the cds construction process by assigning the reference cds to the full coverage query transcript.
```{r buildcds}
query_cds <- buildCDS(query_exons, ref_cds, 
                        Mmusculus, q2rcovs, coverage = 3)

head(query_cds)
```

We can visualize the cds structure using *wiggleplotr*
```{r viewcds}
plotTranscripts(query_exons, query_cds)
```

## Analyze functional consequence of coding transcripts

### Predicting protein features

To extract protein coding features found in our list of coding transcripts, we can run the `extractCDSfeature` function using our `query_cds` and `Mmusculus` objects as input. This tool will currently query the translated protein sequence for two features: protein domains and signal peptide. 
```{r testfeature, eval=F}
extractCDSfeature(query_cds, Mmusculus)
## A tibble: 4 x 3
#  id          Domains                   SignalP_prob
#  <chr>       <chr>                            <dbl>
#1 transcript1 4xRNA-binding domain, RBD     0.000575
#2 transcript2 4xRNA-binding domain, RBD     0.000575
#3 transcript3 2xRNA-binding domain, RBD     0.000575
#4 transcript4 4xRNA-binding domain, RBD     0.000575
```

In order to extract the domain features, `extractCDSfeature` will attempt to submit the protein coding sequence to the SuperFamily database and return a summary of the domain structure. As this process is done over HTTP, the speed of this function is greatly dependent on the server and on the number of cds in your list. This process can be sped up by subsetting the list of cds for analysis using the `which` argument.
```{r testfeaturewhich, eval=F}
extractCDSfeature(query_cds, Mmusculus, which = c('transcript1', 'transcript3'))
## A tibble: 2 x 3
#  id          Domains                   SignalP_prob
#  <chr>       <chr>                            <dbl>
#1 transcript1 4xRNA-binding domain, RBD     0.000575
#2 transcript3 2xRNA-binding domain, RBD     0.000575
```

### Predicting NMD-inducing features

To test whether any of our sample coding transcripts are targets of NMD, we can run the `predictNMD` function using our `query_exons` and `query_cds` GRangesList as input:
```{r testnmd1}
predictNMD(query_exons, query_cds)
```

The column containing logical values for `is_NMD` is determined based on whether the `dist_to_lastEJ` value exceed the `NMDthreshold` argument. The `NMDthreshold` value is set to 50(bp) as default, but can be altered based on users' requirement. The `which` argument accepts a list of transcript names found in query and will return results listed in the argument. This may be useful if you are interested in several transcripts within a big GRangesList object.
```{r testnmdwhich}
predictNMD(query_exons, query_cds, which = c('transcript1', 'transcript3'))
```

## Search coding transcripts for upstream and overlapping ORFs

Coding transcripts with long 5' untranslated regions may contain multiple start codons. This may be recognized by ribosomes as an initiating site for translation and create additional upstream open-reading frame or overlapping open-reading frame with the cds. To test for presence of upstream or overlapping ORFs, we can run `searchuORFs` function using `query_exons`, `query_cds` and our fasta `Mmusculus` as inputs.
```{r testuorfs}
# test for uORFs
uORFs <- searchuORFs(query_exons, query_cds, Mmusculus)

# inspect output
names(uORFs)

names(uORFs$exons)

```

`searchuORFs` will return a list object containing a pair of exon and cds information of uORFs found. Each uORF will be named by its type (uORF or uATG), index of the uORF found in the transcript and its parent transcript name. The returned object can be separated into two separate objects zeallot's unpacking feature
```{r testuorfsunpack}
# test for uORFs
c(uORFs_exons, uORFs_cds) %<-% searchuORFs(query_exons, query_cds, Mmusculus)

# inspect output
names(uORFs_exons)

names(uORFs_cds)

```

`searchuORFs` can also append the list of uORFs found to the original `query_exons` and `query_cds` lists.
```{r testuorfsappend}
# test for uORFs
c(newquery_exons, newquery_cds) %<-% searchuORFs(query_exons, query_cds, 
                                              Mmusculus, append = T)

# inspect output
names(newquery_exons)

names(newquery_cds)

```

With the new list of coding transcript, we can retest the list for functional consequence.
```{r retestuorf}
# visualize new list
plotTranscripts(newquery_exons, newquery_cds)

# retest list for NMD features
predictNMD(newquery_exons, newquery_cds)

```

## Merging exon and cds objects for export

After constructing query cds entries, one may be interested in combining the exon and cds objects and save it as a GTF file. factR comes a `mergeExonsCDS` function which effeciently unlists the GRangeList objects, fill any missing important attributes (type and transcript_id) and combine them into a single GRanges object. 
```{r merge}
# combine exons and cds objects
newquery_gtf <- mergeExonsCDS(newquery_exons, newquery_cds)
newquery_gtf

```

The returned object may then be exported as a GTF file using rtracklayer's export function
```{r output, eval=F}
# save newquery_gtf as gtf file
export(newquery_gtf, 'path/to/output.gtf', format = 'gtf')
```

# Other exported functions
## Resize GRanges transcript

GRanges objects may contain exon coordinates from a single transcript. Users who wish to trim the ends of this exon block may utilize the `resizeTranscripts` function. This is particularly useful to shorten transcripts to its cds coordinates or lengthening the 5' end of a transcript to include promoter sequences:
```{r resizeexamples}
# trim ends of transcript1
transcript1_trimmed <- resizeTranscript(query_exons$transcript1, start = 100, end = 1000)

# add 500bp to 5' end of transcript1
transcript1_lengthen <- resizeTranscript(query_exons$transcript1, start = -500)

# combine the GRanges into a list and visualize
combine <- list('transcript1' = query_exons$transcript1, 
                'transcript1_trimmed' = transcript1_trimmed, 
                'transcript1_lengthen' = transcript1_lengthen)
plotTranscripts(combine)

```
