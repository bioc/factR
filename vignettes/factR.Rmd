---
title: "Using factR"
author: "Fursham Hamid"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    number_sections: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{factR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE, cache=FALSE}
## Global options
options(max.print="75")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>")
knitr::opts_knit$set(width=75)
```


```{r silentload, include=FALSE}
#Silent load all dependencies for vignette
library(factR)
library(BSgenome.Mmusculus.UCSC.mm10)
library(wiggleplotr)
library(GenomicFeatures)
library(dplyr)
```

# Introduction
High throughput RNA sequencing experiments have been very useful in the discovery of many new RNA species. Current pipelines that processes these sequencing data usually involve aligning the reads to a genome and assembling contiguous reads into a transcript architectures. With the assembled transcripts, one may quantify the relative number of reads mapped to the list of genes/transcripts and determine differentially expressed gene/transcripts between conditions. However, these assembled transcripts commonly do not contain information on its coding potential and thus inferring its function can be a difficult task.

Here, we developed a program with tools to Functionally Annotate Custom-assembled Transcripts in R (factR). At its core, factR will construct CDS coordinates for assembled transcriptomes with the guide of a reference annotation. With this newly-built coding information, users may utilise factR to query transcripts for protein-coding features as well as NMD-inducing features. 


# Getting started

To run the code examples shown in this vignette, we need to load the following packages:
```{r load.dep.workflow, eval = FALSE}
library(factR)
library(BSgenome.Mmusculus.UCSC.mm10)
library(wiggleplotr)
library(GenomicFeatures)
library(dplyr)
library(rtracklayer)
library(AnnotationHub)
library(Biostrings)
```


## How to install
To install factR, open R and type:
```{r install.factR, eval = FALSE}
install.packages("devtools")
devtools::install_github("fursham-h/factR")
```

## What you need

### Query transcript assembly

Transcript assembly programs typically outputs a GTF/GFF3 file containing transcript and exon coordinates, as well as attributes for each entry. It is mandatory that your assembly contain *gene_id* and *transcript_id* attributes.

Query GTF file have to be imported into R and parsed into a GenomicRanges object. 
To do so, run:
```{r load,query, eval = FALSE}
# import gtf file using rtracklayer
query_gtf <- import('path/to/your.gtf')
```

### Reference annotation

Reference transcript annotation serves as a guide in the construction of query CDS. We strongly recommend using transcript annotation in GTF/GFF3 format for the workflow. Reference GTF annotation can be acquired from the Annotation Hub database in R or downloaded locally from data server website via FTP. For the latter, the GTF file have to be imported into R and parsed into a GenomicRanges object. 

Here, we will describe three ways to obtain mouse GRCm38 annotation:

1. Gencode annotation from Annotation Hub database
```{r load.gencode, eval = FALSE}
# query database for mouse gencode basic annotation
ah <- AnnotationHub()
query(ah, c('Mus musculus', 'gencode', 'gff', 'basic'))
#> AnnotationHub with 2 records
#> # snapshotDate(): 2019-05-02 
#> # $dataprovider: Gencode
#> # $species: Mus musculus
#> # $rdataclass: GRanges
#> # additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer,
#> #   rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype 
#> # retrieve records with, e.g., 'object[["AH49547"]]' 
#> 
#>             title                                                    
#>   AH49547 | gencode.vM6.basic.annotation.gff3.gz                     
#>   AH49549 | gencode.vM6.chr_patch_hapl_scaff.basic.annotation.gff3.gz

#>  retrieve id 'AH49547'
ref_gtf <- ah[['AH49547']]
```

2. Ensembl annotation from Annotation Hub database
```{r load.ensembl, eval = FALSE}
# Load annotation hub and query database for ensembl annotation as in method 1 above.

# retrieve latest GRCm38 annotation from ensembl
ref_gtf <- ah[['AH60127']]
```

3. Import locally downloaded GTF annotation into R
```{r load.localref, eval = FALSE}
# import reference gtf file
query_gtf <- import('path/to/reference.gtf')
```


### Genomic sequence

Genomic DNA sequence is required for determining open-reading frames and for *in silico* translation of  query transcripts. Here, we describe three ways to obtain genomic sequence for mouse GRCm38 assembly:

1. BSgenome sequence object from UCSC
```{r load.BSgenome, eval = FALSE}
# install GRCm38 sequence object and rename for convenience
BiocManager::install("BSgenome.Mmusculus.UCSC.mm10")
library(BSgenome.Mmusculus.UCSC.mm10)
Mmusculus <- BSgenome.Mmusculus.UCSC.mm10
```

2. TwoBit fasta sequence from Annotation Hub
```{r load.fastaAH, eval = FALSE}
# query database for mouse gencode basic annotation
ah <- AnnotationHub()
query(ah, c("Mus musculus", "release-91", 'fasta', 'GRCm38'))
#> AnnotationHub with 5 records
#> # snapshotDate(): 2019-05-02 
#> # $dataprovider: Ensembl
#> # $species: Mus musculus
#> # $rdataclass: TwoBitFile
#> # additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer,
#> #   rdatadateadded, preparerclass, tags, rdatapath, sourceurl, sourcetype 
#> # retrieve records with, e.g., 'object[["AH60491"]]' 
#> 
#>             title                                           
#>   AH60491 | Mus_musculus.GRCm38.cdna.all.2bit               
#>   AH60492 | Mus_musculus.GRCm38.dna.primary_assembly.2bit   
#>   AH60493 | Mus_musculus.GRCm38.dna_rm.primary_assembly.2bit
#>   AH60494 | Mus_musculus.GRCm38.dna_sm.primary_assembly.2bit
#>   AH60495 | Mus_musculus.GRCm38.ncrna.2bit  

#>  retrieve id 'AH60492'
Mmusculus <- ah[['AH60492']]
```

3. Import local FASTA genome sequence file
```{r load.localfasta, eval = FALSE}
# load package and import fasta file as a DNAStringSet
Mmusculus <- readDNAStringSet('path/to/fasta')
```

Note: when using DNA FASTA from Ensembl, do check header lines for entry names. If long names are given (eg. 1 dna:chromosome chromosome:GRCm38:1:1:195471971:1 REF), you would need to convert them to short names in order to have consistent sequence levels. This can be done by running the following:

```{r convert.fastaheader, eval = FALSE}
# load package and import fasta file as a DNAStringSet
library(purrr)
library(stringr)
names(Mmusculus) <- str_split(seqlevels(Mmusculus), " ") %>% map_chr(`[`, 1)
```


# Sample datasets

## **Query** 
factR package contains a sample assembled GTF imported as a GRanges object. The assembly was constructed from a mouse dataset and contain *transcript* and *exon* descriptions of 4 transcript isoforms from the same parent gene. Transcripts in `query_gtf` have been assigned generic gene_ids and transcript_ids. This is to recapitulate the nomenclature of a typical custom-assembled GTF.
```{r checkquery}
# inspect query object
head(query_gtf)

# list out transcript_id and gene_id names
unique(query_gtf$transcript_id)

unique(query_gtf$gene_id)
```


We can quickly visualize the exon structure of these query transcripts using the *wiggleplotr* package
```{r viewquery}
# prepare a list of exons by transcript
query_exons <- split(query_gtf[query_gtf$type == 'exon'], ~transcript_id)

# list out transcript_id and gene_id names
plotTranscripts(query_exons)
```

## **Reference** 
For our reference annotation, we will be using a subset of GRCm38 gencode reference annotation which contain basic transcripts from the same gene family as our query gene. 
```{r viewref}
# inspect reference object
head(ref_gtf)

# list out transcript_id and gene_id names
unique(ref_gtf$transcript_id)

unique(ref_gtf$gene_id)
```

# Matching chromosome levels



# Matching gene_id and gene_name metadata



# Construct query CDS information

To build CDS information on our query data, simply run:
```{r buildcds}
new_query_gtf <- buildCDS(query_gtf, ref_gtf, Mmusculus)
```

The above function will return a new GRanges object containing exon entries from `query_gtf` and newly-constructed cds entries. We can inspect the contents of the object further.
```{r checkCDS}
# check lengths of input and output GRanges
length(query_gtf)

length(new_query_gtf)

# inspect CDS entries
head(new_query_gtf[mcols(new_query_gtf)$type == "CDS"])
```

We can visualize the coding structure of each transcripts using the *wiggleplotr* package:
```{r viewCDS}
# get GrangesList of query exons and cds
query_exons <- split(new_query_gtf[new_query_gtf$type == 'exon'], ~transcript_id)
query_cds <- split(new_query_gtf[new_query_gtf$type == 'CDS'], ~transcript_id)

plotTranscripts(query_exons, query_cds)
```

The new query GTF Granges object can be exported as a .gtf file using `rtracklayer`'s export funcition:
```{r export, eval=FALSE}
# get GrangesList of query exons and cds
rtracklayer::export(new_query_gtf, 'path/to/output.gtf', format = 'gtf')
```


# Extracting protein features on coding transcripts

# Predicting NMD-inducing features on coding transcripts

Nonsense-mediated decay (NMD) is an RNA surveillance program which eliminates messenger RNAs containing a premature stop codon. 

To test whether any of our sample transcripts are NMD-sensitive, we can run the `predictNMD` function using the newly-built `new_query_gtf` object as input:
```{r testnmd1}
predictNMD(new_query_gtf)
```

The column containing logical values for `is_NMD` is determined based on whether the `dist_to_lastEJ` value exceed the `NMD_threshold` argument. The `NMD_threshold` value is set to 50(bp) as default, but can be altered based on users' requirement. 





The `which` argument accepts a list of transcript names found in query and will return results listed in the argument. This may be useful if you are interested in several transcripts within a big GRangesList object.
```{r testnmdwhich}
predictNMD(query_exons, query_cds, which = c('transcript1', 'transcript3'))
```






# Session Information

All of the output in this vignette was produced under the following conditions:
```{r sessioninfo}
sessionInfo()
```


## Check and rectify input objects for cross-compatibility

Before running the core functions of factR, we have to ensure that the mandatory input objects are cross-compatible for the analysis. Two key features that has to be consistent among the inputs include:

1. Chromosome ID (seqlevels). 
This is required for many downstream analyses, including extraction of transcript sequence and construction of query CDS.
2. Matched gene_id between query and reference. 
This is required to pair query transcripts to a reference transcript based on common gene family in order to construct its CDS information.

factR comes with a tool to check the mandatory input files and return recommendations on functions to execute to increase consistency of your query object. To check the input files, run:
```{r checkinputs}
checkInputs(query_gtf, ref_gtf, Mmusculus)
```

As seen from the report above, our `query_gtf` object has inconsistent chromosome levels (seqlevels) and gene_ids. To rectify these inconsistencies, you may follow the functions as recommended.
```{r matchfuns}
# matching seqlevels
query_gtf <- matchSeqLevels(query_gtf, Mmusculus)

head(query_gtf)

# matching gene_id
query_gtf <- matchGeneIDs(query_gtf, ref_gtf)

head(query_gtf)
```

After `query_gtf`  have been rectified, we can re-check our inputs:
```{r recheckinputs}
checkInputs(query_gtf, ref_gtf, Mmusculus)
```


## Construct query CDS


## Extracting protein features on coding transcripts

To extract protein coding features found in our list of coding transcripts, we can run the `extractCDSfeature` function using our `query_cds` and `Mmusculus` objects as input. By default, this tool will query the SuperFamily database for domain features by calling out the `hmmer` function from `bio3d` package. The function will output 3 output fields: 'desc', 'evalue' and 'nincluded'. 
```{r testfeature, eval=F}
extractCDSfeature(query_cds, Mmusculus)
#> # A tibble: 4 x 4
#>   id          hmmer.desc              hmmer.evalue hmmer.nincluded
#>   <chr>       <chr>                          <dbl>           <dbl>
#> 1 transcript1 RNA-binding domain, RBD     2.80e-81               4
#> 2 transcript2 RNA-binding domain, RBD     2.10e-81               4
#> 3 transcript3 RNA-binding domain, RBD     1.30e-43               2
#> 4 transcript4 RNA-binding domain, RBD     1.20e-72               4
```

More fields from the `hmmer` function can be requested by providing a list of fields to the hmmer argument:
```{r testfeature2, eval=F}
extractCDSfeature(query_cds, Mmusculus, hmmer = c('default', 'bitscore', 'pvalue'))
#> # A tibble: 4 x 6
#>   id          hmmer.desc              hmmer.evalue hmmer.nincluded hmmer.bitscore hmmer.pvalue
#>   <chr>       <chr>                          <dbl>           <dbl>          <dbl>        <dbl>
#> 1 transcript1 RNA-binding domain, RBD     2.80e-81               4           266.        -195.
#> 2 transcript2 RNA-binding domain, RBD     2.10e-81               4           267.        -195.
#> 3 transcript3 RNA-binding domain, RBD     1.30e-43               2           146.        -108.
#> 4 transcript4 RNA-binding domain, RBD     1.20e-72               4           239         -175.
```

In order to extract the domain features, `extractCDSfeature` will attempt to submit the protein coding sequence to the SuperFamily database and return a summary of the domain structure. As this process is done over HTTP, the speed of this function is greatly dependent on the server and on the number of CDS in your list. This process can be sped up by subsetting the list of CDS for analysis using the `which` argument.
```{r testfeaturewhich, eval=F}
extractCDSfeature(query_cds, Mmusculus, which = c('transcript1', 'transcript3'))
#> # A tibble: 2 x 4
#>   id          hmmer.desc              hmmer.evalue hmmer.nincluded
#>   <chr>       <chr>                          <dbl>           <dbl>
#> 1 transcript1 RNA-binding domain, RBD     2.80e-81               4
#> 2 transcript2 RNA-binding domain, RBD     2.10e-81               4
```

## Predicting NMD-inducing features on coding transcripts

To test whether any of our sample coding transcripts are targets of NMD, we can run the `predictNMD` function using our `query_exons` and `query_cds` GRangesList as input:
```{r testnmd1}
predictNMD(query_exons, query_cds)
```

The column containing logical values for `is_NMD` is determined based on whether the `dist_to_lastEJ` value exceed the `NMDthreshold` argument. The `NMDthreshold` value is set to 50(bp) as default, but can be altered based on users' requirement. The `which` argument accepts a list of transcript names found in query and will return results listed in the argument. This may be useful if you are interested in several transcripts within a big GRangesList object.
```{r testnmdwhich}
predictNMD(query_exons, query_cds, which = c('transcript1', 'transcript3'))
```

## Search coding transcripts for upstream and overlapping ORFs

Coding transcripts with long 5' untranslated regions may contain multiple start codons. This may be recognized by ribosomes as an initiating site for translation and create additional upstream open-reading frame or overlapping open-reading frame with the cds. To test for presence of upstream or overlapping ORFs, we can run `searchuORFs` function using `query_exons`, `query_cds` and our fasta `Mmusculus` as inputs.
```{r testuorfs}
# test for uORFs
uORFs <- searchuORFs(query_exons, query_cds, Mmusculus)

# inspect output
names(uORFs)

names(uORFs$exons)

```

`searchuORFs` will return a list object containing a pair of exon and cds information of uORFs found. Each uORF will be named by its type (uORF or uATG), index of the uORF found in the transcript and its parent transcript name. The returned object can be separated into two separate objects zeallot's unpacking feature
```{r testuorfsunpack}
# test for uORFs
c(uORFs_exons, uORFs_cds) %<-% searchuORFs(query_exons, query_cds, Mmusculus)

# inspect output
names(uORFs_exons)

names(uORFs_cds)

```

`searchuORFs` can also append the list of uORFs found to the original `query_exons` and `query_cds` lists.
```{r testuorfsappend}
# test for uORFs
c(newquery_exons, newquery_cds) %<-% searchuORFs(query_exons, query_cds, 
                                              Mmusculus, append = T)

# inspect output
names(newquery_exons)

names(newquery_cds)

```

With the new list of coding transcript, we can retest the list for functional consequence.
```{r retestuorf}
# visualize new list
plotTranscripts(newquery_exons, newquery_cds)

# retest list for NMD features
predictNMD(newquery_exons, newquery_cds)

```

## Compare and classify alternative segments between transcripts

RNA transcripts commonly undergo alternative splicing to give rise to two or more isoforms. Each isoform may contain distinct segments that may ultimately affect the function of its translated protein. To compare and classify alternative segments between two transcripts, we can run the `compareAS` function that comes with factR.

`compareAS` analyzes alternative spliced segments in two modes: pair-wise and intra-list. In pair-wise mode, we have to provide two GRanges objects for comparison. THe function will return a GRanges with segments included/skipped in the first transcript as compared to the second transcript
```{r compareAS1}
# compare transcript1 to transcript2
compareAS(query_exons$transcript1, query_exons$transcript2)

```

In intralist mode, we can provide a GRangesList object containing exon coordinates for a set of transcripts. If a gene_id attribute is present as a metadata column, the function will group transcripts by its gene family and create transcript pairs for comparsion. 
```{r compareAS2}
# compare transcript1 to transcript2
compareAS(query_exons)

```

